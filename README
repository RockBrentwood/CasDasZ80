CasDasZ80
━━━━━━━━━
The Z80 CPU was widely used in the 1980's in many home computers.
Even today it is often used as a cheap embedded CPU.
If you need more information can get one of the following books:

DasZ80 Disassembler
───────────────────
Originally Z80 Disassembler, it was created by Markuz Fritze (sarnau), as a small disassembler for a Z80 CPU in an afternoon.
It is a command-line tool.
Currently, the size of the ROM and entry points need to be hard-coded.
It is gradually being migrated over to the design of the DAS disassembler, which currently only has a public-facing port for the 8051,
(currently under https://github.com/RockBrentwood/CPU/tree/main/8051/csd4-archive/assem), and previously also had a local port for the 8080 and 8085.
There is enough congruence in their designs to facilitate the migration to DAS.

This program should compile with any C++ compiler.
It only uses some ANSI C functions (look into ‟main()”).
C++98 should be sufficient, compatibility should continue to hold for C++11 on up, for future changes.
Current program versions can be compiled successfully with ‟gcc”.
Z80DisAssembler has also compiled with ‟clang” without warnings, therefore DasZ80 should, as well.

The program has two parts:
▪	Analyze the code.
	The disassembler tries to analyze what part of the binary data is program code and what part is data.
	It start with all hardware vectors of the Z80 (‟RST” opcodes, ‟NMI”) and parses all jumps via a recursive analyze via ‟ParseOpcode()”.
	Every opcode is marked in an array (‟OpcodesFlags”).
	There are some exceptions, the parser can't recognize:
	―	Self Modifying Code:
		A ROM shouldn't contain such code.
		To properly handle this would require run-time emulation.
		Examples where this occurs include self-unpacking, self-decrypting and/or self-loading code.
	―	Indirect Jumps: calculated branches with ‟JP (IY)”, ‟JP (IX)” or ‟JP (HL)”.
		The parser can't recognize them, either.
		The set of possible destinations has to be determined by analysis and added separately as entry points.
	―	Indirect Jumps: organized as jump tables.
		These are quite common in a ROM.
		The same applies here, as with calculated branches.
		If you find a jump table - like on Markuz' Futura aquarium computer - more entry points for ‟ParseOpcodes()” will need to be added.
	―	Unused code.
		This can be code that is reached from an unrecognized destination of an indirect jump, or as an unrecognized entry point.
		It if assumes a regular form, consisting particularly of bytes are in the range of printable characters, then it may be initialized data.
		It if assumes a regular form, like a block of 0's, then it may be uninitialized data.
		By default, it is treated as part of the data area of the program
▪	Disassembly of the code.
	With the help of the OpcodesFlags table the disassembler now creates the output.
	This subroutine is quite long.
	It disassembles one opcode at a specific address in ROM into a buffer.
	It is coded directly from a list of Z80 opcodes, so the handling of ‟IX” and ‟IY” could be optimized quite a lot.

The subroutine ‟OpcodeLen()” returns the size of one opcode in bytes.
It is called while parsing and while disassembling.

The disassembler recognizes some hidden opcodes.

If a routine wanted an ‟address” to the Z80 code, it is in fact an offset to the array of code.
No pointers!
Longs are not necessary for a Z80, because the standard Z80 only supports 64k.

This program is freeware.
It may not be used as a base for a commercial product!

CasZ80 Assembler
────────────────
Originally the Z80 assembler, it was created by Markuz Fritze (sarnau), as an assembler for the Z80,
a few days after the Z80 disassembler was created, to compile the changes coded from the disassembler into an EPROM image
and build a new firmware for Markuz' aquarium computer.
Almost two days were needed for the assembler, this means: command-line only...
If you want to change the filename of the sourcefile, you have to change main().

This small assembler has some nice gadgets: it is a quite fast tokenizing single-pass assembler with backpatching.
It knows all official Z80 opcodes and some undocumented opcodes (mainly with ‟IX” and ‟IY”).
The Z80 syntax is documented in the Zilog documentation.

It is being slated for migration to a Z80 port of the CAS assembler, whose only public-facing port currently is for the 8051
(also under https://github.com/RockBrentwood/CPU/tree/main/8051/csd4-archive/assem).
There is enough congruence in the design of the Z80 assembler with the CAS assembler, which is also a single-pass assembler with backpatching,
to facilitate the migration to a Z80 port of the CAS.

The assembler allows mathematical expressions in operands:
	‟+”, ‟-”, ‟*”, ‟/”, ‟%” (modulo),
	‟&” (and), ‟|” (or), ‟!” (not), ‟^” (xor), ‟<<” (shift left) and ‟>>” (shift right).
Brackets are also available.
The expression parser is located in ‟Exp.c”.
Numbers can be postpended by a ‟D”, ‟H” or ‟B” for decimal, hexadecimal and binary numbers.
Numbers prepended by a ‟$” are recognized as hex.

The assembler also knows the most commend pseudo opcodes (look into the sourcefile ‟Lex.cpp”):
‟;”		This line is a comment.
‟IF”		Start the conditional expression.
		If false, the following sourcecode will be skipped (until ‟ELSE” or ‟ENDIF”).
‟ENDIF”		End of the condition expression.
‟ELSE”		Include the following code, when the expression on ‟IF” was false.
‟END”		End of the sourcecode.
		The assembler stops here.
		Optional.
‟ORG”		Set the PC in the 64k address space.
		E.g. to generate code for address $2000.
‟PRINT”		Print the following text on the console.
		Great for testing the assembler.
‟EQU”/‟=”	Set a variable.
‟DEFB”/‟DB”	Put a byte at the current address
‟DEFW”/‟DW”	Put a word at the current address (little endian!)
‟DEFM”/‟DM”	Put a string or several bytes seperated with a ‛,’ in the memory, starting at the current address.
‟DEFS”/‟DS”	Set the current address n bytes ahead.
		Defines space for global variables that have no given value.

The Source Code
───────────────
Cas.cpp:	Assembler driver
Cas.h:		Assembler declarations
Das.cpp:	Disassembler
Exp.cpp:	Assembler expression parser
Lex.cpp:	Assembler lexer
Syn.cpp:	Assembler main parser
Hex.h:		Intel Hex Input/Output common declarations
HexIn.c:	Intel Hex Input
HexIn.h:	Intel Hex Input, declarations
HexEx.c:	Intel Hex Output
HexEx.h:	Intel Hex Output, declarations
